## 〇、概要

### 成员变量

```c++
vector<int> sets;	// 表示各个节点所属的集合
vector<int> ranks;	// 表示各个节点所属集合的秩，即树的高度
```

## 一、初始化

对于所有 $n$ 个节点，初始化时各单独在一个集合，将其所属集合初始化为本身，$rank$ 初始化为 $1$。

```c++
DisjointSet(const int &n) : sets(n), ranks(n, 1)
{
	for (int i = 0; i < n; ++i)
	{
		sets[i] = i;
	}
}
```

## 二、查找所在集合

### 1. 简单查询

检查当前节点所属集合是否是其本身，如果是，则返回当前节点的编号，否则递归往上搜索其父节点。

```c++
int Find_Set(int x)
{
	while (sets[x] != x)
	{
		x = sets[x];
	}
	return x;
}
```

### 2. 路径压缩

查找过程可进行路径压缩处理，将查找路径上节点都直接连接到集合根节点上，后续查找速度会更快。

但要注意该方式会破坏树的结构，在部分情况下不能使用。

```c++
int Find_Set(int x)
{
	int root = x;
	while (sets[root] != root)
	{
		root = sets[root];
	}
	while (sets[x] != root)
	{
		int father = sets[x];
		sets[x] = root;
		x = father;
	}
	return root;
}
```

### 3. 递归简化代码

当路径压缩和按秩合并同时使用时，每次查询集合时的查询次数不超过 $5$，可以采用递归写法简化代码。

相较于循环写法，递归写法代码更简便，且在递归层数不超过 $5$ 的一般情况下不会有过度消耗时间或者栈溢出的情况发生。

> **以下证明来源于 $deepseek$：**
>
> 在并查集中，同时使用路径压缩和按秩合并时，递归深度最多不超过5层的原因与阿克曼函数（Ackermann function）的反函数α(n)的极慢增长特性密切相关：
>
> 1. **按秩合并控制树高增长**
>    按秩合并确保树的高度仅在两棵同秩的树合并时增加1。这使得树高的增长极其缓慢，类似于对数级别。
> 1. **路径压缩动态优化结构**
>    路径压缩在查找时将节点直接指向根节点，使后续操作的时间复杂度显著降低。多次查找后，树会逐渐趋于扁平化。
> 1. **阿克曼函数的反函数限制**
>    并查集的时间复杂度由阿克曼函数的反函数α(n)主导。该函数增长极为缓慢，对于任何实际物理可实现的数据规模（如n ≤ 10^100），α(n) ≤ 5。
> 1. **递归深度与α(n)的关系**
>    递归深度对应于树的高度。由于α(n)在现实场景中最大为5，因此即使数据规模极大，递归调用最多只需5层即可到达根节点。
>
> **结论**
> 路径压缩和按秩合并的协同作用，使得树高被严格限制在α(n)的范围内。而α(n)在实际应用中不超过5，因此递归深度自然被限制在5层以内。这一结果确保了并查集操作的极高效率，使其接近常数时间复杂度。

```c++
int Find_Set(const int &x)
{
	return sets[x] == x ? x : sets[x] = Find_Set(sets[x]);
}
```

## 三、集合合并

### 1. 简单合并

将一个集合的根节点直接挂载到另一个集合的根节点上。

```c++
void Merge_Set(const int &x, const int &y)
{
    sets[Find_Set(x)] = Find_Set(y);
}
```

### 2. 按秩合并

对于上述合并方式，随合并次数增加，会导致树的重心像一侧偏移。

为了让树尽可能平衡，可以采用按秩合并的方式，每次将高度较小的树挂载到高度较大的那棵树上。

```c++
void Merge_Set(const int &x, const int &y)
{
	int set_x = Find_Set(x);
	int set_y = Find_Set(y);
	if (ranks[set_x] < ranks[set_y])
	{
		sets[set_x] = set_y;
	}
	else
	{
		sets[set_y] = set_x;
        // 仅当两棵树的高度相等时，新树的高度要增加 1
		if (ranks[set_x] == ranks[set_y])
			++ranks[set_x];
	}
}
```

## 四、种类并查集

普通并查集只能表示“属于同一集合”的关系，当节点间存在多种关系时，应当使用种类并查集。

实现种类并查集可采用虚拟节点法，对于 $x$ 种关系的并查集问题，将数组扩容到 $x$ 倍，每一段长度为 $n$ 的区间表示一种关系。

合并两个元素的关系时，根据两者之间的种类关系，对于 $x$ 对不同的区间组合分别合并。